// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: abacus_metric.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_abacus_5fmetric_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_abacus_5fmetric_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_abacus_5fmetric_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_abacus_5fmetric_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_abacus_5fmetric_2eproto;
namespace abacus {
namespace protobuf {
class Info;
struct InfoDefaultTypeInternal;
extern InfoDefaultTypeInternal _Info_default_instance_;
class Metric;
struct MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class Metrics;
struct MetricsDefaultTypeInternal;
extern MetricsDefaultTypeInternal _Metrics_default_instance_;
}  // namespace protobuf
}  // namespace abacus
PROTOBUF_NAMESPACE_OPEN
template<> ::abacus::protobuf::Info* Arena::CreateMaybeMessage<::abacus::protobuf::Info>(Arena*);
template<> ::abacus::protobuf::Metric* Arena::CreateMaybeMessage<::abacus::protobuf::Metric>(Arena*);
template<> ::abacus::protobuf::Metrics* Arena::CreateMaybeMessage<::abacus::protobuf::Metrics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace abacus {
namespace protobuf {

enum Kind : int {
  COUNTER = 0,
  CONSTANT = 1,
  GAUGE = 2,
  Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Kind_IsValid(int value);
constexpr Kind Kind_MIN = COUNTER;
constexpr Kind Kind_MAX = GAUGE;
constexpr int Kind_ARRAYSIZE = Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Kind_descriptor();
template<typename T>
inline const std::string& Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Kind_descriptor(), enum_t_value);
}
inline bool Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Kind>(
    Kind_descriptor(), name, value);
}
enum Type : int {
  UINT64 = 0,
  INT64 = 1,
  FLOAT64 = 2,
  BOOL = 3,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = UINT64;
constexpr Type Type_MAX = BOOL;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abacus.protobuf.Info) */ {
 public:
  inline Info() : Info(nullptr) {}
  ~Info() override;
  explicit PROTOBUF_CONSTEXPR Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Info(const Info& from);
  Info(Info&& from) noexcept
    : Info() {
    *this = ::std::move(from);
  }

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Info& operator=(Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Info& default_instance() {
    return *internal_default_instance();
  }
  enum MinCase {
    kUint64Min = 6,
    kInt64Min = 7,
    kFloat64Min = 8,
    MIN_NOT_SET = 0,
  };

  enum MaxCase {
    kUint64Max = 9,
    kInt64Max = 10,
    kFloat64Max = 11,
    MAX_NOT_SET = 0,
  };

  static inline const Info* internal_default_instance() {
    return reinterpret_cast<const Info*>(
               &_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Info& a, Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Info& from) {
    Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abacus.protobuf.Info";
  }
  protected:
  explicit Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kUnitFieldNumber = 5,
    kTypeFieldNumber = 3,
    kKindFieldNumber = 4,
    kUint64MinFieldNumber = 6,
    kInt64MinFieldNumber = 7,
    kFloat64MinFieldNumber = 8,
    kUint64MaxFieldNumber = 9,
    kInt64MaxFieldNumber = 10,
    kFloat64MaxFieldNumber = 11,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string unit = 5;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // .abacus.protobuf.Type type = 3;
  void clear_type();
  ::abacus::protobuf::Type type() const;
  void set_type(::abacus::protobuf::Type value);
  private:
  ::abacus::protobuf::Type _internal_type() const;
  void _internal_set_type(::abacus::protobuf::Type value);
  public:

  // .abacus.protobuf.Kind kind = 4;
  void clear_kind();
  ::abacus::protobuf::Kind kind() const;
  void set_kind(::abacus::protobuf::Kind value);
  private:
  ::abacus::protobuf::Kind _internal_kind() const;
  void _internal_set_kind(::abacus::protobuf::Kind value);
  public:

  // uint64 uint64_min = 6;
  bool has_uint64_min() const;
  private:
  bool _internal_has_uint64_min() const;
  public:
  void clear_uint64_min();
  uint64_t uint64_min() const;
  void set_uint64_min(uint64_t value);
  private:
  uint64_t _internal_uint64_min() const;
  void _internal_set_uint64_min(uint64_t value);
  public:

  // int64 int64_min = 7;
  bool has_int64_min() const;
  private:
  bool _internal_has_int64_min() const;
  public:
  void clear_int64_min();
  int64_t int64_min() const;
  void set_int64_min(int64_t value);
  private:
  int64_t _internal_int64_min() const;
  void _internal_set_int64_min(int64_t value);
  public:

  // double float64_min = 8;
  bool has_float64_min() const;
  private:
  bool _internal_has_float64_min() const;
  public:
  void clear_float64_min();
  double float64_min() const;
  void set_float64_min(double value);
  private:
  double _internal_float64_min() const;
  void _internal_set_float64_min(double value);
  public:

  // uint64 uint64_max = 9;
  bool has_uint64_max() const;
  private:
  bool _internal_has_uint64_max() const;
  public:
  void clear_uint64_max();
  uint64_t uint64_max() const;
  void set_uint64_max(uint64_t value);
  private:
  uint64_t _internal_uint64_max() const;
  void _internal_set_uint64_max(uint64_t value);
  public:

  // int64 int64_max = 10;
  bool has_int64_max() const;
  private:
  bool _internal_has_int64_max() const;
  public:
  void clear_int64_max();
  int64_t int64_max() const;
  void set_int64_max(int64_t value);
  private:
  int64_t _internal_int64_max() const;
  void _internal_set_int64_max(int64_t value);
  public:

  // double float64_max = 11;
  bool has_float64_max() const;
  private:
  bool _internal_has_float64_max() const;
  public:
  void clear_float64_max();
  double float64_max() const;
  void set_float64_max(double value);
  private:
  double _internal_float64_max() const;
  void _internal_set_float64_max(double value);
  public:

  void clear_min();
  MinCase min_case() const;
  void clear_max();
  MaxCase max_case() const;
  // @@protoc_insertion_point(class_scope:abacus.protobuf.Info)
 private:
  class _Internal;
  void set_has_uint64_min();
  void set_has_int64_min();
  void set_has_float64_min();
  void set_has_uint64_max();
  void set_has_int64_max();
  void set_has_float64_max();

  inline bool has_min() const;
  inline void clear_has_min();

  inline bool has_max() const;
  inline void clear_has_max();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    int type_;
    int kind_;
    union MinUnion {
      constexpr MinUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t uint64_min_;
      int64_t int64_min_;
      double float64_min_;
    } min_;
    union MaxUnion {
      constexpr MaxUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t uint64_max_;
      int64_t int64_max_;
      double float64_max_;
    } max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_abacus_5fmetric_2eproto;
};
// -------------------------------------------------------------------

class Metric final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abacus.protobuf.Metric) */ {
 public:
  inline Metric() : Metric(nullptr) {}
  ~Metric() override;
  explicit PROTOBUF_CONSTEXPR Metric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metric(const Metric& from);
  Metric(Metric&& from) noexcept
    : Metric() {
    *this = ::std::move(from);
  }

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metric& operator=(Metric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metric& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kUint64Value = 2,
    kInt64Value = 3,
    kFloat64Value = 4,
    kBoolValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Metric* internal_default_instance() {
    return reinterpret_cast<const Metric*>(
               &_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Metric& a, Metric& b) {
    a.Swap(&b);
  }
  inline void Swap(Metric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metric>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metric& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metric& from) {
    Metric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abacus.protobuf.Metric";
  }
  protected:
  explicit Metric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kUint64ValueFieldNumber = 2,
    kInt64ValueFieldNumber = 3,
    kFloat64ValueFieldNumber = 4,
    kBoolValueFieldNumber = 5,
  };
  // optional .abacus.protobuf.Info info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::abacus::protobuf::Info& info() const;
  PROTOBUF_NODISCARD ::abacus::protobuf::Info* release_info();
  ::abacus::protobuf::Info* mutable_info();
  void set_allocated_info(::abacus::protobuf::Info* info);
  private:
  const ::abacus::protobuf::Info& _internal_info() const;
  ::abacus::protobuf::Info* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::abacus::protobuf::Info* info);
  ::abacus::protobuf::Info* unsafe_arena_release_info();

  // uint64 uint64_value = 2;
  bool has_uint64_value() const;
  private:
  bool _internal_has_uint64_value() const;
  public:
  void clear_uint64_value();
  uint64_t uint64_value() const;
  void set_uint64_value(uint64_t value);
  private:
  uint64_t _internal_uint64_value() const;
  void _internal_set_uint64_value(uint64_t value);
  public:

  // int64 int64_value = 3;
  bool has_int64_value() const;
  private:
  bool _internal_has_int64_value() const;
  public:
  void clear_int64_value();
  int64_t int64_value() const;
  void set_int64_value(int64_t value);
  private:
  int64_t _internal_int64_value() const;
  void _internal_set_int64_value(int64_t value);
  public:

  // double float64_value = 4;
  bool has_float64_value() const;
  private:
  bool _internal_has_float64_value() const;
  public:
  void clear_float64_value();
  double float64_value() const;
  void set_float64_value(double value);
  private:
  double _internal_float64_value() const;
  void _internal_set_float64_value(double value);
  public:

  // bool bool_value = 5;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:abacus.protobuf.Metric)
 private:
  class _Internal;
  void set_has_uint64_value();
  void set_has_int64_value();
  void set_has_float64_value();
  void set_has_bool_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::abacus::protobuf::Info* info_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      uint64_t uint64_value_;
      int64_t int64_value_;
      double float64_value_;
      bool bool_value_;
    } value_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_abacus_5fmetric_2eproto;
};
// -------------------------------------------------------------------

class Metrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:abacus.protobuf.Metrics) */ {
 public:
  inline Metrics() : Metrics(nullptr) {}
  ~Metrics() override;
  explicit PROTOBUF_CONSTEXPR Metrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metrics(const Metrics& from);
  Metrics(Metrics&& from) noexcept
    : Metrics() {
    *this = ::std::move(from);
  }

  inline Metrics& operator=(const Metrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metrics& operator=(Metrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metrics* internal_default_instance() {
    return reinterpret_cast<const Metrics*>(
               &_Metrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Metrics& a, Metrics& b) {
    a.Swap(&b);
  }
  inline void Swap(Metrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Metrics& from) {
    Metrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "abacus.protobuf.Metrics";
  }
  protected:
  explicit Metrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricFieldNumber = 2,
    kProtocolVersionFieldNumber = 1,
  };
  // repeated .abacus.protobuf.Metric metric = 2;
  int metric_size() const;
  private:
  int _internal_metric_size() const;
  public:
  void clear_metric();
  ::abacus::protobuf::Metric* mutable_metric(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abacus::protobuf::Metric >*
      mutable_metric();
  private:
  const ::abacus::protobuf::Metric& _internal_metric(int index) const;
  ::abacus::protobuf::Metric* _internal_add_metric();
  public:
  const ::abacus::protobuf::Metric& metric(int index) const;
  ::abacus::protobuf::Metric* add_metric();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abacus::protobuf::Metric >&
      metric() const;

  // uint32 protocol_version = 1;
  void clear_protocol_version();
  uint32_t protocol_version() const;
  void set_protocol_version(uint32_t value);
  private:
  uint32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:abacus.protobuf.Metrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abacus::protobuf::Metric > metric_;
    uint32_t protocol_version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_abacus_5fmetric_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Info

// string name = 1;
inline void Info::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Info::name() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.name)
}
inline std::string* Info::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:abacus.protobuf.Info.name)
  return _s;
}
inline const std::string& Info::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Info::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_name() {
  // @@protoc_insertion_point(field_release:abacus.protobuf.Info.name)
  return _impl_.name_.Release();
}
inline void Info::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abacus.protobuf.Info.name)
}

// string description = 2;
inline void Info::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Info::description() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.description)
}
inline std::string* Info::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:abacus.protobuf.Info.description)
  return _s;
}
inline const std::string& Info::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Info::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_description() {
  // @@protoc_insertion_point(field_release:abacus.protobuf.Info.description)
  return _impl_.description_.Release();
}
inline void Info::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abacus.protobuf.Info.description)
}

// .abacus.protobuf.Type type = 3;
inline void Info::clear_type() {
  _impl_.type_ = 0;
}
inline ::abacus::protobuf::Type Info::_internal_type() const {
  return static_cast< ::abacus::protobuf::Type >(_impl_.type_);
}
inline ::abacus::protobuf::Type Info::type() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.type)
  return _internal_type();
}
inline void Info::_internal_set_type(::abacus::protobuf::Type value) {
  
  _impl_.type_ = value;
}
inline void Info::set_type(::abacus::protobuf::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.type)
}

// .abacus.protobuf.Kind kind = 4;
inline void Info::clear_kind() {
  _impl_.kind_ = 0;
}
inline ::abacus::protobuf::Kind Info::_internal_kind() const {
  return static_cast< ::abacus::protobuf::Kind >(_impl_.kind_);
}
inline ::abacus::protobuf::Kind Info::kind() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.kind)
  return _internal_kind();
}
inline void Info::_internal_set_kind(::abacus::protobuf::Kind value) {
  
  _impl_.kind_ = value;
}
inline void Info::set_kind(::abacus::protobuf::Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.kind)
}

// string unit = 5;
inline void Info::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& Info::unit() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Info::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.unit)
}
inline std::string* Info::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:abacus.protobuf.Info.unit)
  return _s;
}
inline const std::string& Info::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void Info::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* Info::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* Info::release_unit() {
  // @@protoc_insertion_point(field_release:abacus.protobuf.Info.unit)
  return _impl_.unit_.Release();
}
inline void Info::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:abacus.protobuf.Info.unit)
}

// uint64 uint64_min = 6;
inline bool Info::_internal_has_uint64_min() const {
  return min_case() == kUint64Min;
}
inline bool Info::has_uint64_min() const {
  return _internal_has_uint64_min();
}
inline void Info::set_has_uint64_min() {
  _impl_._oneof_case_[0] = kUint64Min;
}
inline void Info::clear_uint64_min() {
  if (_internal_has_uint64_min()) {
    _impl_.min_.uint64_min_ = uint64_t{0u};
    clear_has_min();
  }
}
inline uint64_t Info::_internal_uint64_min() const {
  if (_internal_has_uint64_min()) {
    return _impl_.min_.uint64_min_;
  }
  return uint64_t{0u};
}
inline void Info::_internal_set_uint64_min(uint64_t value) {
  if (!_internal_has_uint64_min()) {
    clear_min();
    set_has_uint64_min();
  }
  _impl_.min_.uint64_min_ = value;
}
inline uint64_t Info::uint64_min() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.uint64_min)
  return _internal_uint64_min();
}
inline void Info::set_uint64_min(uint64_t value) {
  _internal_set_uint64_min(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.uint64_min)
}

// int64 int64_min = 7;
inline bool Info::_internal_has_int64_min() const {
  return min_case() == kInt64Min;
}
inline bool Info::has_int64_min() const {
  return _internal_has_int64_min();
}
inline void Info::set_has_int64_min() {
  _impl_._oneof_case_[0] = kInt64Min;
}
inline void Info::clear_int64_min() {
  if (_internal_has_int64_min()) {
    _impl_.min_.int64_min_ = int64_t{0};
    clear_has_min();
  }
}
inline int64_t Info::_internal_int64_min() const {
  if (_internal_has_int64_min()) {
    return _impl_.min_.int64_min_;
  }
  return int64_t{0};
}
inline void Info::_internal_set_int64_min(int64_t value) {
  if (!_internal_has_int64_min()) {
    clear_min();
    set_has_int64_min();
  }
  _impl_.min_.int64_min_ = value;
}
inline int64_t Info::int64_min() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.int64_min)
  return _internal_int64_min();
}
inline void Info::set_int64_min(int64_t value) {
  _internal_set_int64_min(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.int64_min)
}

// double float64_min = 8;
inline bool Info::_internal_has_float64_min() const {
  return min_case() == kFloat64Min;
}
inline bool Info::has_float64_min() const {
  return _internal_has_float64_min();
}
inline void Info::set_has_float64_min() {
  _impl_._oneof_case_[0] = kFloat64Min;
}
inline void Info::clear_float64_min() {
  if (_internal_has_float64_min()) {
    _impl_.min_.float64_min_ = 0;
    clear_has_min();
  }
}
inline double Info::_internal_float64_min() const {
  if (_internal_has_float64_min()) {
    return _impl_.min_.float64_min_;
  }
  return 0;
}
inline void Info::_internal_set_float64_min(double value) {
  if (!_internal_has_float64_min()) {
    clear_min();
    set_has_float64_min();
  }
  _impl_.min_.float64_min_ = value;
}
inline double Info::float64_min() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.float64_min)
  return _internal_float64_min();
}
inline void Info::set_float64_min(double value) {
  _internal_set_float64_min(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.float64_min)
}

// uint64 uint64_max = 9;
inline bool Info::_internal_has_uint64_max() const {
  return max_case() == kUint64Max;
}
inline bool Info::has_uint64_max() const {
  return _internal_has_uint64_max();
}
inline void Info::set_has_uint64_max() {
  _impl_._oneof_case_[1] = kUint64Max;
}
inline void Info::clear_uint64_max() {
  if (_internal_has_uint64_max()) {
    _impl_.max_.uint64_max_ = uint64_t{0u};
    clear_has_max();
  }
}
inline uint64_t Info::_internal_uint64_max() const {
  if (_internal_has_uint64_max()) {
    return _impl_.max_.uint64_max_;
  }
  return uint64_t{0u};
}
inline void Info::_internal_set_uint64_max(uint64_t value) {
  if (!_internal_has_uint64_max()) {
    clear_max();
    set_has_uint64_max();
  }
  _impl_.max_.uint64_max_ = value;
}
inline uint64_t Info::uint64_max() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.uint64_max)
  return _internal_uint64_max();
}
inline void Info::set_uint64_max(uint64_t value) {
  _internal_set_uint64_max(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.uint64_max)
}

// int64 int64_max = 10;
inline bool Info::_internal_has_int64_max() const {
  return max_case() == kInt64Max;
}
inline bool Info::has_int64_max() const {
  return _internal_has_int64_max();
}
inline void Info::set_has_int64_max() {
  _impl_._oneof_case_[1] = kInt64Max;
}
inline void Info::clear_int64_max() {
  if (_internal_has_int64_max()) {
    _impl_.max_.int64_max_ = int64_t{0};
    clear_has_max();
  }
}
inline int64_t Info::_internal_int64_max() const {
  if (_internal_has_int64_max()) {
    return _impl_.max_.int64_max_;
  }
  return int64_t{0};
}
inline void Info::_internal_set_int64_max(int64_t value) {
  if (!_internal_has_int64_max()) {
    clear_max();
    set_has_int64_max();
  }
  _impl_.max_.int64_max_ = value;
}
inline int64_t Info::int64_max() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.int64_max)
  return _internal_int64_max();
}
inline void Info::set_int64_max(int64_t value) {
  _internal_set_int64_max(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.int64_max)
}

// double float64_max = 11;
inline bool Info::_internal_has_float64_max() const {
  return max_case() == kFloat64Max;
}
inline bool Info::has_float64_max() const {
  return _internal_has_float64_max();
}
inline void Info::set_has_float64_max() {
  _impl_._oneof_case_[1] = kFloat64Max;
}
inline void Info::clear_float64_max() {
  if (_internal_has_float64_max()) {
    _impl_.max_.float64_max_ = 0;
    clear_has_max();
  }
}
inline double Info::_internal_float64_max() const {
  if (_internal_has_float64_max()) {
    return _impl_.max_.float64_max_;
  }
  return 0;
}
inline void Info::_internal_set_float64_max(double value) {
  if (!_internal_has_float64_max()) {
    clear_max();
    set_has_float64_max();
  }
  _impl_.max_.float64_max_ = value;
}
inline double Info::float64_max() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Info.float64_max)
  return _internal_float64_max();
}
inline void Info::set_float64_max(double value) {
  _internal_set_float64_max(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Info.float64_max)
}

inline bool Info::has_min() const {
  return min_case() != MIN_NOT_SET;
}
inline void Info::clear_has_min() {
  _impl_._oneof_case_[0] = MIN_NOT_SET;
}
inline bool Info::has_max() const {
  return max_case() != MAX_NOT_SET;
}
inline void Info::clear_has_max() {
  _impl_._oneof_case_[1] = MAX_NOT_SET;
}
inline Info::MinCase Info::min_case() const {
  return Info::MinCase(_impl_._oneof_case_[0]);
}
inline Info::MaxCase Info::max_case() const {
  return Info::MaxCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Metric

// optional .abacus.protobuf.Info info = 1;
inline bool Metric::_internal_has_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_ != nullptr);
  return value;
}
inline bool Metric::has_info() const {
  return _internal_has_info();
}
inline void Metric::clear_info() {
  if (_impl_.info_ != nullptr) _impl_.info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::abacus::protobuf::Info& Metric::_internal_info() const {
  const ::abacus::protobuf::Info* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::abacus::protobuf::Info&>(
      ::abacus::protobuf::_Info_default_instance_);
}
inline const ::abacus::protobuf::Info& Metric::info() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metric.info)
  return _internal_info();
}
inline void Metric::unsafe_arena_set_allocated_info(
    ::abacus::protobuf::Info* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:abacus.protobuf.Metric.info)
}
inline ::abacus::protobuf::Info* Metric::release_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abacus::protobuf::Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::abacus::protobuf::Info* Metric::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:abacus.protobuf.Metric.info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::abacus::protobuf::Info* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::abacus::protobuf::Info* Metric::_internal_mutable_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::abacus::protobuf::Info>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::abacus::protobuf::Info* Metric::mutable_info() {
  ::abacus::protobuf::Info* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:abacus.protobuf.Metric.info)
  return _msg;
}
inline void Metric::set_allocated_info(::abacus::protobuf::Info* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:abacus.protobuf.Metric.info)
}

// uint64 uint64_value = 2;
inline bool Metric::_internal_has_uint64_value() const {
  return value_case() == kUint64Value;
}
inline bool Metric::has_uint64_value() const {
  return _internal_has_uint64_value();
}
inline void Metric::set_has_uint64_value() {
  _impl_._oneof_case_[0] = kUint64Value;
}
inline void Metric::clear_uint64_value() {
  if (_internal_has_uint64_value()) {
    _impl_.value_.uint64_value_ = uint64_t{0u};
    clear_has_value();
  }
}
inline uint64_t Metric::_internal_uint64_value() const {
  if (_internal_has_uint64_value()) {
    return _impl_.value_.uint64_value_;
  }
  return uint64_t{0u};
}
inline void Metric::_internal_set_uint64_value(uint64_t value) {
  if (!_internal_has_uint64_value()) {
    clear_value();
    set_has_uint64_value();
  }
  _impl_.value_.uint64_value_ = value;
}
inline uint64_t Metric::uint64_value() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metric.uint64_value)
  return _internal_uint64_value();
}
inline void Metric::set_uint64_value(uint64_t value) {
  _internal_set_uint64_value(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Metric.uint64_value)
}

// int64 int64_value = 3;
inline bool Metric::_internal_has_int64_value() const {
  return value_case() == kInt64Value;
}
inline bool Metric::has_int64_value() const {
  return _internal_has_int64_value();
}
inline void Metric::set_has_int64_value() {
  _impl_._oneof_case_[0] = kInt64Value;
}
inline void Metric::clear_int64_value() {
  if (_internal_has_int64_value()) {
    _impl_.value_.int64_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Metric::_internal_int64_value() const {
  if (_internal_has_int64_value()) {
    return _impl_.value_.int64_value_;
  }
  return int64_t{0};
}
inline void Metric::_internal_set_int64_value(int64_t value) {
  if (!_internal_has_int64_value()) {
    clear_value();
    set_has_int64_value();
  }
  _impl_.value_.int64_value_ = value;
}
inline int64_t Metric::int64_value() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metric.int64_value)
  return _internal_int64_value();
}
inline void Metric::set_int64_value(int64_t value) {
  _internal_set_int64_value(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Metric.int64_value)
}

// double float64_value = 4;
inline bool Metric::_internal_has_float64_value() const {
  return value_case() == kFloat64Value;
}
inline bool Metric::has_float64_value() const {
  return _internal_has_float64_value();
}
inline void Metric::set_has_float64_value() {
  _impl_._oneof_case_[0] = kFloat64Value;
}
inline void Metric::clear_float64_value() {
  if (_internal_has_float64_value()) {
    _impl_.value_.float64_value_ = 0;
    clear_has_value();
  }
}
inline double Metric::_internal_float64_value() const {
  if (_internal_has_float64_value()) {
    return _impl_.value_.float64_value_;
  }
  return 0;
}
inline void Metric::_internal_set_float64_value(double value) {
  if (!_internal_has_float64_value()) {
    clear_value();
    set_has_float64_value();
  }
  _impl_.value_.float64_value_ = value;
}
inline double Metric::float64_value() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metric.float64_value)
  return _internal_float64_value();
}
inline void Metric::set_float64_value(double value) {
  _internal_set_float64_value(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Metric.float64_value)
}

// bool bool_value = 5;
inline bool Metric::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool Metric::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void Metric::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Metric::clear_bool_value() {
  if (_internal_has_bool_value()) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Metric::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return _impl_.value_.bool_value_;
  }
  return false;
}
inline void Metric::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
}
inline bool Metric::bool_value() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metric.bool_value)
  return _internal_bool_value();
}
inline void Metric::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Metric.bool_value)
}

inline bool Metric::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Metric::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Metric::ValueCase Metric::value_case() const {
  return Metric::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Metrics

// uint32 protocol_version = 1;
inline void Metrics::clear_protocol_version() {
  _impl_.protocol_version_ = 0u;
}
inline uint32_t Metrics::_internal_protocol_version() const {
  return _impl_.protocol_version_;
}
inline uint32_t Metrics::protocol_version() const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metrics.protocol_version)
  return _internal_protocol_version();
}
inline void Metrics::_internal_set_protocol_version(uint32_t value) {
  
  _impl_.protocol_version_ = value;
}
inline void Metrics::set_protocol_version(uint32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:abacus.protobuf.Metrics.protocol_version)
}

// repeated .abacus.protobuf.Metric metric = 2;
inline int Metrics::_internal_metric_size() const {
  return _impl_.metric_.size();
}
inline int Metrics::metric_size() const {
  return _internal_metric_size();
}
inline void Metrics::clear_metric() {
  _impl_.metric_.Clear();
}
inline ::abacus::protobuf::Metric* Metrics::mutable_metric(int index) {
  // @@protoc_insertion_point(field_mutable:abacus.protobuf.Metrics.metric)
  return _impl_.metric_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abacus::protobuf::Metric >*
Metrics::mutable_metric() {
  // @@protoc_insertion_point(field_mutable_list:abacus.protobuf.Metrics.metric)
  return &_impl_.metric_;
}
inline const ::abacus::protobuf::Metric& Metrics::_internal_metric(int index) const {
  return _impl_.metric_.Get(index);
}
inline const ::abacus::protobuf::Metric& Metrics::metric(int index) const {
  // @@protoc_insertion_point(field_get:abacus.protobuf.Metrics.metric)
  return _internal_metric(index);
}
inline ::abacus::protobuf::Metric* Metrics::_internal_add_metric() {
  return _impl_.metric_.Add();
}
inline ::abacus::protobuf::Metric* Metrics::add_metric() {
  ::abacus::protobuf::Metric* _add = _internal_add_metric();
  // @@protoc_insertion_point(field_add:abacus.protobuf.Metrics.metric)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::abacus::protobuf::Metric >&
Metrics::metric() const {
  // @@protoc_insertion_point(field_list:abacus.protobuf.Metrics.metric)
  return _impl_.metric_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace abacus

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::abacus::protobuf::Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abacus::protobuf::Kind>() {
  return ::abacus::protobuf::Kind_descriptor();
}
template <> struct is_proto_enum< ::abacus::protobuf::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::abacus::protobuf::Type>() {
  return ::abacus::protobuf::Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_abacus_5fmetric_2eproto
